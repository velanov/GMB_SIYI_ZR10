Step 1 – Parse KMZ/KML Coordinates
Tools: fastkml, simplekml, or pykml Python libs.
Goal: Extract <Placemark> entries (latitude, longitude, altitude).

Plan:
Write a parser that converts KML/KMZ into a list[(lat, lon, alt)].
Feed this list into your “fix coordinate function” instead of just one coordinate.
Add logic: either cycle through all points or allow selection of one.

Step 2 – Adapt Loiter + Gimbal Tracking
Existing Function: Works with a single target.
Change Needed: Extend it to accept a list of waypoints.

Implementation Options:
Sequential tracking → go to point A, loiter, then move to B.
Dynamic switching → operator can pick the next target from the list.
Deliverable: Modified mission planner that supports multi-target loiter.

Step 3 – Real-time Telemetry Feed to Google Earth
Telemetry Source: MAVLink via pymavlink or mavsdk-python.
Data: GLOBAL_POSITION_INT or GPS_RAW_INT messages (lat, lon, alt).

Integration Method:
Dynamic KML NetworkLink → Generate a doc.kml with <NetworkLink> that fetches position updates from your program.
Live KML Refresh → Python writes to a KML file every X seconds, and Google Earth auto-refreshes.
Deliverable:
A uav.kml file that updates with the UAV’s real-time position.
Plane shown as a custom icon (e.g., airplane model).

Step 4 – Simulated/3D View in Google Earth
Approach 1 (Lightweight): Use Google Earth desktop → load UAV’s live KML feed → you can follow the aircraft in 3D terrain.

Approach 2 (More Advanced):
Use Google Earth Pro’s “tour” mode to animate the UAV’s path.
Sync altitude & heading from MAVLink.
Optional Extension: Use CesiumJS (open-source Google Earth alternative) for real-time 3D in a browser (PX4 + telemetry → WebSocket → Cesium map).


⚙️ Tech Stack Recap
Parsing KMZ/KML: simplekml, pykml, fastkml
PX4 Telemetry: pymavlink, mavsdk-python
Google Earth Live Feed: Dynamic KML with <NetworkLink>
Simulation: PX4 SITL + Gazebo/JMAVSim